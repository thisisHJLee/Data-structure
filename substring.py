def solve(str):
	x = dict() # 0과 1의 개수의 차이와 차이가 처음 발생하는 위치를 저장하는 딕셔너리를 만든다

	x[0] = -1 # 시작 전 차이는 없다

	count_0 = 0 # 0의 개수를 저장하는 변수
	count_1 = 0 # 1의 개수를 저장하는 변수
	n = len(str) # 문자열의 길이를 저장하는 변수
	max_len = 0 # 최대 부문자열의 길이를 저장하는 변수
	
	for i in range(n):
		# 0과 1의 개수를 count
		if str[i] == '0':
			count_0 += 1
		else:
			count_1 += 1

		if x.get(count_0 - count_1) == None: # 현재 위치 i에서 0과 1의 개수의 차이가 처음 나타난 경우. 그 차이를 key로 가지는 곳에 인덱스 i를 저장
			x[count_0 - count_1] = i
		else:
			# 0과 1의 개수의 차이가 이미 발생했던 경우. 이전에 차이가 발생한 인덱스부터 현재 차이가 발생한 인덱스까지의 부문자열은 같은 개수의 0과 1을 갖는다. 이 부문자열이 더 길다면, max_len를 업데이트한다
			if max_len < i - x[count_0 - count_1]:
				max_len = i - x[count_0 - count_1]

	return max_len
	
"""

연산 수행시간이 상수시간 O(1)로 가장 빠른 딕셔너리를 사용했다.
딕셔너리는 key, value를 한 쌍으로 갖고, key 값을 통해 value 값을 얻는 자료구조이다.

solve 함수의 알고리즘은 다음과 같다.
1) for문을 이용해 0과 1의 개수를 각각 변수에 저장하며 센다.
2) 0과 1의 개수의 차이가 처음 발생하면 그 차이를 key로 가지는 곳에 인덱스를 저장
3) 0과 1의 개수의 차이가 발생한 적이 있다면 이전 인덱스부터 현재 인덱스까지의 부문자열은 0과 1의 개수가 같은 것이다. 부문자열의 길이를 체크한다.

solve는 문자열의 길이 n까지의 for 반복문을 1번 돌고, 딕셔너리의 key 값에 따른 value를 확인하는 함수 get의 시간복잡도는 O(1)이므로,
이 함수의 수행시간을 분석하면 T(cn + c) = O(n)이기 때문에 solve의 시간복잡도는 O(n)이다.

"""

A = input().strip()
print(solve(A))